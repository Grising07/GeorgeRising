Week 1: 

programminging is a skill that you learn by doing. videos, books and even lectures can help you, but you learn to program by programming. 

a program is a set of instrusctions to express how to solve a problem, or perform a task
it is written in a specialised language that can be executed by a computer and read and understood by other programmers. 


a program is like a set of instructions 

Sequence- steps carried out in order one at a time
Selection- some steps are included or omitted

reading a program is easy but writing one is harder. this is simply because there is a lot more to it 
you need to be able to find problems, understand the causes and fix them. 

experience is the key to programming. the problem is you cannot learn experience from books and notes, this means you must gain it by practice and making mistakes.

"programming is the art of telling another human being what one wants the computer to do." Donald Kuth 




Week 2: programming languages: 

"you have to know the past to understand the present" Carl Sagan 

why do we have computers? computers are really good at carrying out repetitive tasks. they are accurate and fast and can work for a long amount of time without getting tired.
humans are really bad at carrying out repetitive tasks as we get bored, tired and make mistakes. 

a computer that carries out a specific task very accurately and quickly has its uses. 
but if we can program it to do different tasks, then we can use the same computer for many different purposes. and it becomes much more useful. 

first generation programming: colossus was programmed using plugs and switches. this might represent a very early form of program. 
early programming was very low level and very specific to the hardware. in effect, every computer was programmed in a different way. 
such programming requires very detailed knowledge of how the specific computer worked. 

second generation programming: programmig moved to a higher level with the introduction of assembly languages. these can be though of as short codes that correspond to the basic operations of the computer. 
assembly languages are still very low level and specific to the CPU. they are not portable between different computers using different CPUs.

Third generation language: since this idea emerged there have been many programming languages. 
some languages follow the obect-orientated paradigm ( java,C#), some are funtional( haskell, scala) some are procedural( C, Pascal), and so on
some languages are multi-paradigm which is python. 









Week 3: Computers and instructions: 

The python interpreter is the program that will execute python code

It can process complete programs or we can use it interactively 
Strictly a python program is a script

Abstraction- a language like python means that we do not need to worry too much about how the computer works. Having a general idea is useful

Arithmetic operations done in CPU
There is a small amount of memory in the CPU
For processing values are copied to and from the CPU

A python statement to create a named value is something like: >>> spam = 42 = 101010

The value is identified as an integer 
The value 42(denary) is stored in memory at an address using an amount of memory suitable for an integer
The name spam is created

Not all values are integers 
Other data types are handled in the same way
Booleans are basically integers anyway. Characters can be represented as unicode values. And floating point numbers can( sort of) work in binary.

String is a collection of 4 characters

The value of an integer is limited by the number of bits used to store one 
The size if floating point numbers is likewise limited

Performance issues- the length of a string is limited by the amount of memory available 
Obviously with many GB of memory it is very unlikely that this will be an issue 
But suppose we want a process to say, 1gb log file 

Inside the CPU:
ALU-arithmetic logic unit
PCU-program control unit
Registers-small amounts 

Errors in programming - syntax errors when the program does not follow the rules of the language
Logic errors are when the program 







Week 4:

What skills does a programmer need
VCS - version control systems 
CSCW Computer supported collaborative work

Certain tools that everyone should be able to use
Basic widnows file management 
Basic linux/ mac file management 
Command line git 
Basic text editors(notepad, vi)

tools are very personal It is important to use the "best" tools. and what is best can be very different for different devs. 
surveys tell us that windows and mac/linux have about a 50/50 share.
VS Code and JetBrains (PyCharm) are also about 50:50.
if you looked at a devs setup, you would probably see that it was highly customised, which is just as it should be 

making a choice of operating system:
cost/ availability
experience
bigger picture/ ecosystems 
suitability 
personal preferences
beliefs

customising: 
preference 
individuality
eyesight
RSI/ other speical needs
sense of ownership

very few programmers work in isolation
programming can be a very social activity
because obviously any non trivial system will require several developers.




week 5: 
programs have bugs:
it is impossible to demonstrate that even the very simplest program does not have a bug.
its imposible to even run the very simplest program in every possible set of conditions. 
the best we can do is build up confidence that a program, probably, works as required. most of the time.
consider for example, that you are using your laptop and phone today in a way that has never been done before by anyone, anywhere, and will never be done again by anyone, anywhere.
or, think about how likely it is that any single race in Mario Kart will ever be exaclty repeated. 

what is a bug: 
a bug is a mistake in a program that causes it to behave unexpectedly or incorrectly.

bugs can arise from a variety of sources, including misunderstandings of the problem domain, incorrect assumptions. and simple human error. 
they can lead to a range of issues, from the minor glitches to major system failures.

errors in programming: 

Syntax errors are when the program does not follow the rules of the language, and it fails to compile or run.

logic (semantic) errors ar when the program runs, but does not do what you intended. 

bugs: there are really two ways in which bugs manifest themselves:

the program appears to run correctly, but produces incorrect results in some situations. 

the program fails in some situations 

the chances of error:
some error conditions are more likely than others. 
obvious errors should be cleared and handled gracefully
but there comes a point where this is not worthwhile. consider the effort in programming, and the additional size of the program. 





Week 6:
Be Happy 
a program specification usually describes what should happen if everything goes to plan. 
all inputs are expected, all output devices are present, and so on. 

It is tempting to code the happy path first,  and with good reason

it is well documented
its the most important part
it may well be the most interesting part
(similarly) - it delivers the most value
sometimes we stray from the path, and we need to code what should happen then. 
also obviously, a program should not just crash when somehting unexpected happens
so we are going to extend significant effort coding what we might think of as the less than happy path.

the range of things:
considering the number of students to be organised into groups, we can confidently say that: 
this value is an integer
the value's lower bound is zero
but can we say anything about the upper bound?
there clearly is one. 

a number is a number
class_size = int(input("how many students are there?"))
the value entered could be a class size 
the value entered is always an integer.
the first could be a domain error, the second could be a type error.

handling errors
one approach is to look before you leap (LBYL)
here, we check everything is ok before we do anything that might cause an error. 
this means we need to validate all inputs and preconditions before proceeding. 





Week 7:

using AI
AI changes many aspects of how we work, including programming. 
























